
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
#include "fractal.h"
 
// Convertion d'un point sur la fractale vers un pixel sur l'écran
int toScreen(FractalParam fp, double a)
{
    return a*fp.zoom;
}
 
// Convertion d'un pixel sur l'écran vers un point sur la fractale
double toFractal(FractalParam fp, int a)
{
    return a/fp.zoom;
}
 
// Calcul du module d'un complexe
double modulus(double a, double b)
{
    return sqrt(a*a + b*b);
}
 
// Dessine le pixel de coordonnée (x;y)
void setpixel(SDL_Surface* dst, int x, int y, Uint32 pixel)
{
    // Vérification de l'emplacement du pixel par rapport à la taille de la SDL_Surface* de destination
    if(x < 0 || x >= dst->w || y < 0 || y >= dst->h)
        return;
 
    *((Uint32*)(dst->pixels) + x + y * dst->w) = pixel;
}
 
//Retourne les paramètres initiaux de la fractale
FractalParam initFractal(int w, int h)
{
    FractalParam fp;
    fp.x = -2.1;
    fp.y = -1.2;
    fp.image_w = w;
    fp.image_h = h;
    fp.iter = 40;
    fp.zoom = 200;
 
    return fp;
}
 
// Zoom sur la fractale
void zoomFractal(FractalParam* fp, int x, int y, double factor)
{
    // Convertion du point sur lequel on zoom sur l'écran vers celui sur la fractale
    double x_reel = toFractal(*fp, x) + fp->x;
    double y_reel = toFractal(*fp, y) + fp->y;
 
    fp->zoom *= factor;
 
    // Repositionnement de la fractale
    fp->x = x_reel - toFractal(*fp, fp->image_w)/2;
    fp->y = y_reel - toFractal(*fp, fp->image_h)/2;
}
 
// Déplace la vue sur la fractale
void moveFractal(FractalParam* fp, int x, int y)
{
    fp->x += toFractal(*fp, x);
    fp->y += toFractal(*fp, y);
}
 
// Dessine la fractale
void drawFractal(FractalParam fp, SDL_Surface* dst)
{
    int x, y;
 
    for(x = 0 ; x < fp.image_w ; x++)
    {
        for(y = 0 ; y < fp.image_h ; y++)
        {
            // Nombre complexe z
            double z_r = 0;
            double z_i = 0;
 
            // Nombre complexe c
            double c_r = toFractal(fp, x) + fp.x;
            double c_i = toFractal(fp, y) + fp.y;
 
            // Nombre d'itérations
            int i = 0;
 
            /*
                Zn+1 = (Zn)^2 + c
                Zn+1 = (z_r+ i*z_i)^2 + c_r + c_i
                Zn+1 = z_r^2 + i^2*z_i^2 + 2*z_r*z_i + c_r + c_i
                Zn+1 = z_r^2 - z_i^2 + 2*z_r*z_i + c_r + c_i
 
                Re(Zn+1) = z_r^2 - z_i^2 + c_r
                Im(Zn+1) = 2*z_r*z_i + c_i
            */
 
            do
            {
                double tmp = z_r;
                z_r = z_r*z_r - z_i*z_i + c_r;
                z_i = 2*tmp*z_i + c_i;
                i++;
            }while(modulus(z_r, z_i) < 4 && i < fp.iter);
 
            if(i == fp.iter)
                setpixel(dst, x, y, SDL_MapRGB(dst->format, 0, 0, 0));
            else
                setpixel(dst, x, y, fp.colorMap[i == fp.iter ? 0 : i*(N_COLORS - 1)/fp.iter]);
        }
    }
}
 
// Dessine les axes
void drawAxis(FractalParam fp, SDL_Surface* dst, Uint32 color)
{
    int i;
 
    for(i = 0 ; i < dst->h ; i++)
        setpixel(dst, toScreen(fp, -fp.x), i, color);
 
    for(i = 0 ; i < dst->w ; i++)
        setpixel(dst, i, toScreen(fp, -fp.y), color);
}

